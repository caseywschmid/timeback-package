---
alwaysApply: false
---

## Procedure: Add a New Endpoint to a Service

### 1. Analyze

Analyzethe raw endpoint documentation provided to you making note of the HTTP method, path, and request/response body.

### 2. Get the endpoint name

Look in TODO.md and find the corresponding name for this endpoint. This will be the name of the method that will be created in the service.

### 3. Determine the service class

Using the path, determine which service class this endpoint belongs to.

- For example, if the path is /ims/oneroster/rostering/v1p2 then the new method will be added to the RosteringService class that is implemented by the OneRosterService class.
- If the service class is not found, you may need to create a new service class. Follow the same patterns found in other service classes to create the new service class. You MUST update the `__init__.py` file in the services directory to include the new service class if you create a new service class.

### 4. Review Models

Analyze the endpoint to determine what parameters it requires (path params, query params, request body params). Do a thorough review of the contents of the /models directory to determine the correct models to use.

**IMPORTANT: Check for existing reusable models before creating new ones:**
- If you need a model that only contains a `sourcedId` field, use `TimebackSourcedIdReference` instead of creating a new model
- Review existing models in `/models` to see if any can be reused or extended
- Only create new models when existing ones don't fit the API requirements

**Model Creation Rules:**
- **Create request/response models when:**
  - 2+ attributes (any combination of path params, query params, or body params)
  - Single non-primitive attribute (complex model, list of models, etc.)
  
- **Do NOT create models when:**
  - Single primitive attribute (str, int, bool, etc.) - pass directly as function parameter or return as `Dict[str, Any]`

**For endpoints with multiple parameters:**
- Include ALL parameters (path, query, body) in a single request model. Whatever the user will need to pass to the endpoint should be included in the request model. 
- The endpoint function extracts what it needs from the model (path params for URL, body params for JSON, etc.)
- This makes the API cleaner for users - they pass one request object with all required data

**Examples:**
- `delete_agent(user_id, agent_sourced_id)` → Create `TimebackDeleteAgentRequest` with both fields
- `add_agent(user_id, agent_sourced_id)` → Create `TimebackAddAgentRequest` with both fields (user_id for path, agent_sourced_id for body)
- `delete_user(sourced_id)` → No model needed (single primitive)
- `get_agents(user_id)` → No model needed (single primitive)

### 5. Create new models

Create the new models that you'll need for the request and response body for the new endpoint if required based on the rules in section 4.

**Model Requirements:**
- Use Pydantic v2 syntax: `model_config = ConfigDict(...)` instead of `class Config:`
- Use `populate_by_name=True` in ConfigDict when field aliases are needed
- Use descriptive field names following Python conventions (snake_case)
- Use aliases when the API uses different naming (e.g., `alias="userId"` for `user_id`)

**Reuse Existing Models:**
- **For simple sourcedId references**: Use `TimebackSourcedIdReference` instead of creating new models
  - Example: If the API requires `{"sourcedId": "..."}`, use `TimebackSourcedIdReference` rather than creating a custom model
  - This model is specifically designed for cases where only `sourcedId` is needed (not the full reference structure)
- **Check existing models first**: Before creating a new model, check if `TimebackOrgRef`, `TimebackSourcedIdReference`, or other existing models can be used

**Docstring Standards:**

All models MUST include comprehensive docstrings documenting attributes for IDE hover tooltips.

**Request Models:**
- List attributes under "Required:" and "Optional:" sections
- Reference nested models: "See TimebackUserRole for structure."
- Reference enums: "See TimebackStatus enum."

**Response Models:**
- List all attributes under "Attributes:" (no Required/Optional distinction)
- Reference nested models: "See TimebackUser for structure."
- Always create response models for structured API responses
- Mirror the exact API response structure (e.g., `{ "user": User }` → `user: TimebackUser`)
- Do NOT post-process - return `ResponseModel.model_validate(data)` directly

**File Updates:**
- Update `models/request/__init__.py` and `models/response/__init__.py` to export new models
- Update `models/__init__.py` if creating new top-level models

**Example Request Model:**
```python
from typing import Optional
from pydantic import BaseModel, ConfigDict, Field
from timeback.models.timeback_sourced_id_ref import TimebackSourcedIdReference
from timeback.enums import TimebackOrgType

class TimebackAddAgentRequest(BaseModel):
    """Request model for adding an agent to a user.
    
    Attributes:
        Required:
            - user_id (str): The sourcedId of the user
            - agent_sourced_id (str): The sourcedId of the agent to add
    """
    
    model_config = ConfigDict(populate_by_name=True)
    user_id: str = Field(..., description="The sourcedId of the user", alias="userId")
    agent_sourced_id: str = Field(..., description="The sourcedId of the agent to add", alias="agentSourcedId")

class TimebackCreateSchoolBody(BaseModel):
    """Body payload for school creation.
    
    Attributes:
        Required:
            - name (str): Name of the school
            - type (TimebackOrgType): Must be TimebackOrgType.SCHOOL
        
        Optional:
            - parent (TimebackSourcedIdReference, optional): Reference to parent organization.
              See TimebackSourcedIdReference for structure.
    """
    
    name: str = Field(..., description="Name of the school")
    type: TimebackOrgType = Field(default=TimebackOrgType.SCHOOL)
    parent: Optional[TimebackSourcedIdReference] = None  # Reuse existing model instead of creating new one
```

**Example Response Model:**
```python
from pydantic import BaseModel, Field
from timeback.models.timeback_user import TimebackUser

class TimebackGetUserResponse(BaseModel):
    """Response model for getting a OneRoster User.
    
    Attributes:
        - user (TimebackUser): User object. See TimebackUser for structure.
    """
    
    user: TimebackUser = Field(..., description="User object")
```


### 6. Create the endpoint function

Create the extracted function that will be used by the service class to make the API call. This function will go in the endpoints directory and will be named after the name of the method you found in TODO.md.

While writing endpoint functions, it is absolutely critical that you add type annotations for EVERY parameter and return value. You should have created the necessary request and response models in the models/request/ and models/response/ directories if they're needed for the endpoint. Also, a thorough review of the available models in the models/ directory will help you determine the correct models to use. If you can type something in this endpoint function, you MUST type it. Don't write new Timeback types - all the types you'll need (with the exception of request and response models that you might have created) are already defined in the models/ directory.

**Handling Request Models:**

If the endpoint requires a request model (2+ parameters or single non-primitive):
- Accept the request model as a single parameter: `def endpoint_name(http: HttpClient, request: TimebackRequestModel) -> ReturnType:`
- Extract path parameters from the request model and use them in the URL path: `f"/path/{request.user_id}/subpath/{request.agent_sourced_id}"`
- **For request body serialization, use Pydantic V2's `model_dump()` method:**
  - Use `request.model_dump(exclude_none=True)` for standard serialization
  - Use `request.model_dump(exclude_none=True, by_alias=True)` when field aliases need to be used (e.g., `scoreScale` instead of `score_scale`)
  - Use `request.model_dump(exclude_none=True, exclude={'field_name'})` to exclude fields that shouldn't be in the body (e.g., path parameters)
  - **DO NOT create custom `to_dict()` methods** - Pydantic V2's `model_dump()` handles all serialization needs
- Extract query parameters from the request model and use them in the query string: `params={"limit": request.limit, "offset": request.offset}`
- The endpoint function is responsible for extracting what it needs from the model and using it appropriately (path, body, query)

If the endpoint does NOT require a request model (single primitive parameter):
- Accept the primitive directly as a parameter: `def endpoint_name(http: HttpClient, sourced_id: str) -> ReturnType:`
- Use it directly in the URL path or query string

**Response Handling:**

- If the response is a complex type (model, list of models), return the typed response model
- If the response is a single primitive or flexible JSON, return `Dict[str, Any]` or `Optional[Dict[str, Any]]`

**Example with Request Model:**
```python
def create_school(http: HttpClient, request: TimebackCreateSchoolRequest) -> TimebackCreateSchoolResponse:
    """Create a new school."""
    # Use model_dump() for body serialization - no custom to_dict() needed
    body: Dict[str, Any] = request.model_dump(exclude_none=True)
    data: Dict[str, Any] = http.post("/ims/oneroster/rostering/v1p2/schools", json=body)
    return TimebackCreateSchoolResponse.model_validate(data)

def put_score_scale(http: HttpClient, request: TimebackPutScoreScaleRequest) -> TimebackPutScoreScaleResponse:
    """Update a score scale."""
    # Exclude sourced_id from body (it's used in URL path)
    # Use by_alias=True to get "scoreScale" instead of "score_scale"
    body: Dict[str, Any] = request.model_dump(
        exclude_none=True, 
        exclude={'sourced_id'}, 
        by_alias=True
    )
    data: Dict[str, Any] = http.put(
        f"/ims/oneroster/gradebook/v1p2/scoreScales/{request.sourced_id}", 
        json=body
    )
    return TimebackPutScoreScaleResponse.model_validate(data)
```

**Example without Request Model:**
```python
def delete_user(http: HttpClient, sourced_id: str) -> Optional[Dict[str, Any]]:
    """Delete a user."""
    # Use primitive parameter directly
    return http.delete(f"/ims/oneroster/rostering/v1p2/users/{sourced_id}")
```

#### Extract non-trivial logic into utilities

While writing this function, you are required to further extract any non-trivial logic into a utility function. This utility function will go in the utils directory and will have a descriptive name that clearly explains the purpose of the function. You'll then import the utility function into the endpoint function and use it to perform the necessary logic.

If you create a new utility function, you MUST update the `__init__.py` file in the utils directory to include the new utility function.

Once you've written the endpoint function and any necessary utility functions, you MUST update the `__init__.py` file in the endpoints directory to include the new endpoint function.

### 7. Plug the new endpoint into the service class

After you've written the endpoint function and any necessary utility functions, plug the new endoint function into the service class that it belongs to. Follow all existing patterns. If you've had to create a new service class and there are no existing patterns to follow, review timeback/services/oneroster/oneroster.py and timeback/services/oneroster/rostering/rostering\*service.py to see how to plug the new endpoint function into the service class.

### 8. Write unit tests

Once you've plugged the new endpoint into the service class, you need to then write unit tests for the new endpoint function and any necessary utility functions that came with it.

- These unit tests will go in the tests/unit/ directory which follows the same file structure as the source code. Place the unit tests in the correct directory based on the file structure of the source code.
- Name the unit tests the same thing as the endpoint function or utility function but with a prepeneded `test*` prefix.
- These unit tests will also be fully typed with the correct request and response models and other Timeback models that are needed for the endpoint. See tests/unit/oneroster/rostering/endpoints/test_create_user.py for an example if you need one.

### 9. Write an api test function

Once you've written the unit tests for the new endpoint, you need to then write a short python function that will directly call this new endpoint. This will be used by the team to make calls to this new endpoint as needed for individual testing and development. This function will go in the tests/api/ directory and that directory also follows the same file structure as the source code. Place the new api test function in the correct directory based on the file structure of the source code. Follow existing patterns.

### 10. Update TODO.md

Once you've written the api test function, you need to then update the TODO.md file to reflect the new endpoint that you've added.

### 11. Write documentation

The next thing to do is to write a short documentation page for the new endpoint. This will go in the timeback/docs/ directory which also follows the same file structure as the source code. Place the new documentation page in the correct directory based on the file structure of the source code. Follow existing patterns. The documentation page should fully explain the new endpoint, how to use it, and any special considerations that should be noted. See timeback/docs/oneroster/rostering/get_all_users.md for an example of how to write the new documentation page.

### 12. Inform the team

Once this is done, inform the team that you've added the new endpoint and that they can now start using it.
