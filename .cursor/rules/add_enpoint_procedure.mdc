---
alwaysApply: true
---
## Procedure: Add a New Endpoint to a Service

Follow these steps to add a new endpoint that adheres to our coding guidelines.

### 0) Identify endpoint path and target service

- Determine the API path and map it to the correct service directory.
  - `/ims/oneroster/rostering/v1p2/...` → `timeback/services/oneroster/rostering/endpoints/`
  - `/ims/oneroster/gradebook/v1p2/...` → `timeback/services/oneroster/gradebook/endpoints/`
  - `/ims/oneroster/resources/v1p2/...` → `timeback/services/oneroster/resources/endpoints/`
  - `/powerpath/...` → `timeback/services/powerpath/endpoints/` (when added)
  - `/ims/case/v1p1/...` → `timeback/services/case/endpoints/` (when added)

Example: `GET /ims/oneroster/rostering/v1p2/users/{sourcedId}` → `oneroster/rostering/endpoints/get_user.py`.

### 1) Create the endpoint function (one file per endpoint)

- File location: `.../endpoints/<action>.py` (descriptive action name, e.g., `get_user.py`).
- Export exactly one public function that performs the HTTP call and returns a typed model.
- Use only the injected `HttpClient` for HTTP; build the full path string; pass explicit query params.
- Extract any non-trivial parsing/validation to `.../utils/` and import it.

Example:

```python
# timeback/services/oneroster/rostering/endpoints/get_user.py
from typing import Any, Dict
from timeback.http import HttpClient
from timeback.models.timeback_user import TimebackUser
from timeback.services.oneroster.rostering.utils.parse_user_response import parse_user_response
from timeback.logs import logger
log = logger.configure_logging(__name__, log_level="DEBUG")

def get_user(http: HttpClient, sourced_id: str) -> TimebackUser:
    params: Dict[str, Any] = {}
    log.debug(f"Params: {params}")
    log.debug(f"Sourced ID: {sourced_id}")
    data: Dict[str, Any] = http.get(f"/ims/oneroster/rostering/v1p2/users/{sourced_id}", params=params)
    log.debug(f"Raw Data: {data}")
    return parse_user_response(data)
```

### 2) Models: separate request vs response; one per file

- Locations:
  - Requests: `timeback/models/request/Timeback_*_Request.py`
  - Responses: `timeback/models/response/Timeback_*_Response.py`
- Naming:
  - Request models: `Timeback_<Action>_Request`
  - Response models: `Timeback_<Action>_Response`
- One model per file. Re-export via package `__init__.py` for convenient imports.
- Validate API data directly with Pydantic in endpoints; do not create trivial parse utilities that only call `model_validate`.

Example response model:

```python
from pydantic import BaseModel, Field
from typing import List
from timeback.models.timeback_user import TimebackUser

class TimebackListUsersResponse(BaseModel):
    users: List[TimebackUser] = Field(...)
    totalCount: int = Field(...)
    pageCount: int = Field(...)
    pageNumber: int = Field(...)
    offset: int = Field(...)
    limit: int = Field(...)
```

### 3) Add utilities if needed

- Location: `.../utils/<purpose>.py` (single function per file).
- Purpose: parsing, transformation, validation, normalization.
- Return a typed model or typed value; raise `ParseError` for parse failures.

Example:

```python
# timeback/services/oneroster/rostering/utils/parse_user_response.py
from typing import Any, Dict
from timeback.models.timeback_user import TimebackUser
from timeback.errors import ParseError

def parse_user_response(data: Dict[str, Any]) -> TimebackUser:
    try:
        payload = data.get("user", data)
        return TimebackUser.model_validate(payload)
    except Exception as e:
        raise ParseError(f"Failed to parse User response: {e}") from e
```

### 4) Wire the endpoint into the service class

- Service class should contain no business logic.
- Add a service method that defers entirely to the endpoint function.
- Place method in the correct service file, e.g., `.../rostering_service.py`.

Example:

```python
# timeback/services/oneroster/rostering/rostering_service.py
from timeback.http import HttpClient
from timeback.models.timeback_user import TimebackUser
from timeback.services.oneroster.rostering.endpoints.get_user import get_user as get_user_endpoint

class RosteringService:
    """Rostering service methods for OneRoster."""

    def __init__(self, http: HttpClient):
        self._http = http

    def get_user(self, sourced_id: str) -> TimebackUser:
        return get_user_endpoint(self._http, sourced_id)
```

### 5) Ensure __init__.py exports are correct

- Update `__init__.py` files to expose new modules only if required by import style.
- Keep exports minimal; prefer explicit imports in service modules.
- Typical pattern requires no changes unless you are adding a new public service or top-level export.

Checklist:
- `timeback/services/oneroster/rostering/__init__.py` (usually unchanged)
- `timeback/services/oneroster/rostering/endpoints/__init__.py` (usually unchanged)

### 6) Use proper models and enums

- Return types must be Pydantic models from `timeback/models`.
- Use enums from `timeback/enums` where applicable.
- Validate and normalize API data into models before returning.

Example signature:

```python
def get_user(http: HttpClient, sourced_id: str) -> TimebackUser: ...
```

### 7) Add unit tests (endpoint + utilities)

- Mirror the service directory structure under `tests/unit/...`.
- Unit-test endpoint function with a mock `HttpClient` (do not hit the network).
- Unit-test each utility function independently.

Structure example:

```text
tests/
  unit/
    oneroster/rostering/endpoints/test_get_user.py
    oneroster/rostering/utils/test_parse_user_response.py
```

Endpoint unit test example:

```python
from timeback.services.oneroster.rostering.endpoints.get_user import get_user
from timeback.models.timeback_user import TimebackUser

class MockHttp:
    def get(self, path, params=None):
        return {"user": {"sourcedId": "u1", "givenName": "A", "familyName": "B", "enabledUser": True, "roles": [], "agents": [], "userProfiles": []}}

def test_get_user_success():
    user = get_user(MockHttp(), "u1")
    assert isinstance(user, TimebackUser)
    assert user.sourcedId == "u1"
```

### 8) Add endpoint documentation

- Location mirrors services under `timeback/docs/...`.
- Follow this format (use `timeback/docs/oneroster/rostering/get_user.md` as the standard):
  - Title: `Service — Domain - Action`
  - Path heading with full HTTP method and path
  - Method, Auth, Description (1–2 lines, no fluff)
  - Path params (names, types, required)
  - Query params (if any; names, types, defaults)
  - Successful response (status + body shape)
  - Error responses mapped to client errors (`AuthError`, `NotFoundError`, `RateLimitError`, `ServerError`, `RequestError`)
  - Python usage snippet with minimal example
  - Notes (brief, only if necessary)

Doc template:

```markdown
## <Service> — <Domain> - <Action>

### <METHOD> <full-path>

- Method: <GET/POST/PUT/DELETE>
- Auth: OAuth2 Client Credentials (Bearer token)
- Description: <what the endpoint returns/does>

Path params:

- `<name>` (<type>, required): <description>

Query params:

- `<name>` (<type>, optional): <description> (default: <value>)

Successful response (HTTP <code>):

- Body: `{ "<root>": <Model> }` or `<Model>`
- Key fields: <brief list>

Error responses:

- 400/422: Request/validation → raises `RequestError`
- 401: Unauthorized → raises `AuthError`
- 403: Forbidden → raises `RequestError`
- 404: Not Found → raises `NotFoundError`
- 429: Too Many Requests → raises `RateLimitError`
- 5xx: Server errors → raises `ServerError`

Python usage:

```python
from timeback import Timeback

client = Timeback()
result = client.<service>.<domain>.<method>(<args>)
```

Notes:

- <brief clarifications only>
```

Example doc path:

```text
timeback/docs/oneroster/rostering/get_user.md
```

### 9) Add runnable API test script (manual smoke test)

- Purpose: Provide a tiny, runnable Python script under `tests/api/...` that calls the new endpoint with hard-coded inputs for quick manual verification (no mocks, no user prompts).
- Structure mirrors the service directory and endpoint name:

```text
tests/
  api/
    <service>/<domain>/<action>.py
```

- Rules:
  - Keep the script minimal and non-interactive; use hard-coded sample inputs.
  - Use `from timeback import Timeback`.
  - Construct the client with default env-based config.
  - Print a concise success output (e.g., a few key fields) or a simple failure message.
  - Do not add these files to unit/integration test runners; they are for manual smoke tests only.

- Template:

```python
from timeback import Timeback

def main():
    client = Timeback()
    # TODO: replace with realistic hard-coded inputs for this endpoint
    result = client.<service>.<domain>.<method>(<args>)
    if not result:
        print("No result")
        return
    # Print a few key fields only
    print(result)

if __name__ == "__main__":
    main()
```

- Examples (existing):

`tests/api/oneroster/rostering/get_user.py`:

```python
from timeback import Timeback

def main():
    client = Timeback()
    sourced_id = "31129aea-12b2-4e9e-a6e5-f5c8b712d674"

    user = client.oneroster.rostering.get_user(sourced_id)
    if not user:
        print("No user found")
        return

    print(user.sourcedId, user.givenName, user.familyName)

if __name__ == "__main__":
    main()
```

`tests/api/oneroster/rostering/get_all_users.py`:

```python
from timeback import Timeback

def main():
    client = Timeback()

    users = client.oneroster.rostering.get_all_users()
    if not users:
        print("No users found")
        return

if __name__ == "__main__":
    main()
```

### 10) Update TODO.md with the new endpoint

- Open `TODO.md` and add entries under the correct API path section.
- Use unchecked boxes `- [ ]` for not-yet-implemented endpoints and a checked box `- [x]` for the endpoint you just added.
- Place the item under the correct resource group (e.g., `/ims/oneroster/rostering/v1p2/users/{sourcedId}` for `get_user`).
- Keep naming consistent with existing items (e.g., `get_user`, `get_all_users`, `create_user`).

Example (for `get_user`):

```markdown
### /ims/oneroster/rostering/v1p2/users/{sourcedId}

- [x] `get_user`
- [ ] `update_user`
- [ ] `delete_user`
```

Example (for a collection endpoint like `get_all_users`):

```markdown
### /ims/oneroster/rostering/v1p2/users/

- [x] `get_all_users`
- [ ] `create_user`
```

### 11) Final checklist before commit

- Endpoint file placed under correct `.../endpoints/` path.
- Service method added that calls exactly one endpoint function.
- Utilities created for non-trivial logic and imported by the endpoint.
- All functions return typed models/enums from `timeback/models` and `timeback/enums`.
- Unit tests for the endpoint and utilities.
- Integration test present and net-zero DB changes ensured.
- Docs added under `timeback/docs/...`.
- `TODO.md` updated with this endpoint and related tasks.
- `__init__.py` files reviewed and updated only if necessary.

### 12) Minimal example: adding `get_user`

- Files added/updated:
  - `timeback/services/oneroster/rostering/endpoints/get_user.py`
  - `timeback/services/oneroster/rostering/utils/parse_user_response.py`
  - `timeback/services/oneroster/rostering/rostering_service.py` (method added)
  - `tests/unit/oneroster/rostering/endpoints/test_get_user.py`
  - `tests/unit/oneroster/rostering/utils/test_parse_user_response.py`
  - `timeback/docs/oneroster/rostering/get_user.md`
  - `TODO.md` updated with the new endpoint


