---
alwaysApply: false
---

## Procedure: Add a New Endpoint to a Service

### 1. Analyze

Analyzethe raw endpoint documentation provided to you making note of the HTTP method, path, and request/response body.

### 2. Get the endpoint name

Look in TODO.md and find the corresponding name for this endpoint. This will be the name of the method that will be created in the service.

### 3. Determine the service class

Using the path, determine which service class this endpoint belongs to.

- For example, if the path is /ims/oneroster/rostering/v1p2 then the new method will be added to the RosteringService class that is implemented by the OneRosterService class.
- If the service class is not found, you may need to create a new service class. Follow the same patterns found in other service classes to create the new service class. You MUST update the `__init__.py` file in the services directory to include the new service class if you create a new service class.

### 4. Review Models

Analyze the request/response body and determine the parameters that will be passed to the method. Do a thorough review of the contents of the /models directory to determine the correct models to use. EVERY endpoint implemented should have FULL typing - including the request and response body for each endpoint if the request or response is more than a single field.

### 5. Create new models

Create the new models that you'll need for the request and response body for the new endpoint if required.

- models/request/ and models/response/ directories have `__init__.py` files that must be updated to include any new models that you've created.
- the models/ directory has a `__init__.py` file that must be updated to include any new models that you've created as well.

### 6. Create the endpoint function

Create the the extracted function that will be used by the service class to make the API call. This function will go in the endpoints directory and will be named after the name of the method you found in TODO.md.

While writing endpoint functions, it is absolutely critical that you add type annotations for EVERY parameter and return value. You should have created the necessary request and response models in the models/request/ and models/response/ directories if they're needed for the endpoint. Also, a thorough review of the available models in the models/ directory will help you determine the correct models to use. If you can type something in this endpoint function, you MUST type it. Dont write new types - all the types you'll need (with the exception of request and response models that you might have created) are already defined in the models/ directory.

#### Extract non-trivial logic into utilities

While writing this function, you are required to further extract any non-trivial logic into a utility function. This utility function will go in the utils directory and will have a descriptive name that clearly explains the purpose of the function. You'll then import the utility function into the endpoint function and use it to perform the necessary logic.

If you create a new utility function, you MUST update the `__init__.py` file in the utils directory to include the new utility function.

Once you've written the endpoint function and any necessary utility functions, you MUST update the `__init__.py` file in the endpoints directory to include the new endpoint function.

### 7. Plug the new endpoint into the service class

After you've written the endpoint function and any necessary utility functions, plug the new endoint function into the service class that it belongs to. Follow all existing patterns. If you've had to create a new service class and there are no existing patterns to follow, review timeback/services/oneroster/oneroster.py and timeback/services/oneroster/rostering/rostering\*service.py to see how to plug the new endpoint function into the service class.

### 8. Write unit tests

Once you've plugged the new endpoint into the service class, you need to then write unit tests for the new endpoint function and any necessary utility functions that came with it.

- These unit tests will go in the tests/unit/ directory which follows the same file structure as the source code. Place the unit tests in the correct directory based on the file structure of the source code.
- Name the unit tests the same thing as the endpoint function or utility function but with a prepeneded `test*` prefix.
- These unit tests will also be fully typed with the correct request and response models and other Timeback models that are needed for the endpoint. See tests/unit/oneroster/rostering/endpoints/test_create_user.py for an example if you need one.

### 9. Write an api test function

Once you've written the unit tests for the new endpoint, you need to then write a short python function that will directly call this new endpoint. This will be used by the team to make calls to this new endpoint as needed for individual testing and development. This function will go in the tests/api/ directory and that directory also follows the same file structure as the source code. Place the new api test function in the correct directory based on the file structure of the source code. Follow existing patterns.

### 10. Update TODO.md

Once you've written the api test function, you need to then update the TODO.md file to reflect the new endpoint that you've added.

### 11. Write documentation

The next thing to do is to write a short documentation page for the new endpoint. This will go in the timeback/docs/ directory which also follows the same file structure as the source code. Place the new documentation page in the correct directory based on the file structure of the source code. Follow existing patterns. The documentation page should fully explain the new endpoint, how to use it, and any special considerations that should be noted. See timeback/docs/oneroster/rostering/get_all_users.md for an example of how to write the new documentation page.

### 12. Inform the team

Once this is done, inform the team that you've added the new endpoint and that they can now start using it.
